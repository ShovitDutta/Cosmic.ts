import { execSync } from "child_process";
import { config } from "dotenv";
import fetch from "node-fetch";
import axios from "axios";
config({ path: ".env" });
async function generateCommitMessage(diff) {
    const prompt = `Generate a concise Git commit message based on the following code changes (diff) for a single file. Follow the Conventional Commits specification (type(scope): description). Identify the affected package or area within the monorepo for the scope. The type should be one of feat, fix, docs, chore, style, refactor, test, build, ci, perf, or revert. The description should be a short, clear summary of the changes.\n\nDiff: ${diff}\n\nCommit message:`;
    try {
        console.log("Attempting to generate commit message using GPT API...");
        const response = await axios.get(`https://api.dreaded.site/api/chatgpt?text=${encodeURIComponent(prompt)}`);
        if (response.data && response.data.success && response.data.result) {
            const message = response.data.result.prompt;
            console.log("Commit message generated by GPT.");
            return message.trim();
        } else console.warn("GPT API did not return a valid result. Trying Gemini APIs.");
    } catch (error) {
        console.error("Error calling GPT API:", error.message);
        console.warn("Falling back to Gemini APIs.");
    }
    const geminiApis = [
        `https://vapis.my.id/api/gemini?q=${encodeURIComponent(prompt)}`,
        `https://api.dreaded.site/api/gemini2?text=${encodeURIComponent(prompt)}`,
        `https://api.ryzendesu.vip/api/ai/gemini?text=${encodeURIComponent(prompt)}`,
        `https://api.siputzx.my.id/api/ai/gemini-pro?content=${encodeURIComponent(prompt)}`,
        `https://api.giftedtech.my.id/api/ai/geminiai?apikey=gifted&q=${encodeURIComponent(prompt)}`,
        `https://api.giftedtech.my.id/api/ai/geminiaipro?apikey=gifted&q=${encodeURIComponent(prompt)}`,
    ];
    for (const api of geminiApis) {
        try {
            console.log(`Attempting to generate commit message using Gemini API: ${api}`);
            const response = await fetch(api);
            const data = await response.json();
            if (data.message || data.data || data.answer || data.result) {
                const message = data.message || data.data || data.answer || data.result;
                console.log("Commit message generated by Gemini.");
                return message.trim();
            }
        } catch (error) {
            console.error(`Error calling Gemini API (${api}):`, error.message);
        }
    }

    console.error("Failed to generate commit message from any AI API.");
    return null;
}

function getStagedFiles() {
    try {
        const files = execSync("git diff --name-only --cached").toString().trim().split("\n");
        return files.filter(file => file.length > 0);
    } catch (error) {
        console.error("Error getting staged files:", error.message);
        return [];
    }
}

function getFileDiff(filePath) {
    try {
        return execSync(`git diff --cached "${filePath}"`).toString();
    } catch (error) {
        console.error(`Error getting diff for ${filePath}:`, error.message);
        return null;
    }
}

function gitCommit(message, filePath) {
    try {
        console.log(`Committing ${filePath} with message:\n${message}`);
        execSync(`git commit -m "${message}" -- "${filePath}"`);
        console.log(`Commit successful for ${filePath}.`);
    } catch (error) {
        console.error(`Error during git commit for ${filePath}:`, error.message);
    }
}

function gitPush() {
    try {
        console.log("Pushing changes...");
        execSync("git push");
        console.log("Push successful.");
    } catch (error) {
        console.error("Error during git push:", error.message);
    }
}

async function main() {
    const stagedFiles = getStagedFiles();
    if (stagedFiles.length === 0) {
        console.log("No staged changes to commit.");
        process.exit(0);
    }

    for (const filePath of stagedFiles) {
        console.log(`Processing file: ${filePath}`);
        const fileDiff = getFileDiff(filePath);
        if (!fileDiff) {
            console.warn(`Skipping ${filePath} due to inability to get diff.`);
            continue;
        }

        const commitMessage = await generateCommitMessage(fileDiff);
        if (commitMessage) {
            gitCommit(commitMessage, filePath);
        } else {
            console.error(`Failed to generate commit message for ${filePath}. Skipping commit for this file.`);
        }
    }
    // if (stagedFiles.length > 0) {
    // gitPush();
    // }
}

main();
